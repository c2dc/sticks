[
  {
    "id": "attack-pattern--b3d682b6-98f2-4fb0-aa3b-b4df007ca70a",
    "name": "Obfuscated Files or Information",
    "description": "Adversaries may attempt to make an executable or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the system or in transit. This is common behavior that can be used across different platforms and the network to evade defenses. \n\nPayloads may be compressed, archived, or encrypted in order to avoid detection. These payloads may be used during Initial Access or later to mitigate detection. Sometimes a user's action may be required to open and [Deobfuscate/Decode Files or Information](https://attack.mitre.org/techniques/T1140) for [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016) Adversaries may also use compressed or archived scripts, such as JavaScript. \n\nPortions of files can also be encoded to hide the plain-text strings that would otherwise help defenders with discovery. (Citation: Linux/Cdorked.A We Live Security Analysis) Payloads may also be split into separate, seemingly benign files that only reveal malicious functionality when reassembled. (Citation: Carbon Black Obfuscation Sept 2016)\n\nAdversaries may also abuse [Command Obfuscation](https://attack.mitre.org/techniques/T1027/010) to obscure commands executed from payloads or directly via [Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059). Environment variables, aliases, characters, and other platform/language specific semantics can be used to evade signature based detections and application control mechanisms. (Citation: FireEye Obfuscation June 2017) (Citation: FireEye Revoke-Obfuscation July 2017)(Citation: PaloAlto EncodedCommand March 2017) ",
    "tactic": "defense-evasion",
    "technique_name": "Obfuscated Files or Information",
    "technique_id": "T1027",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1027: Obfuscated Files or Information'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1027: Obfuscated Files or Information'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1027: Obfuscated Files or Information'"
      }
    ],
    "ability_id": "attack-pattern--b3d682b6-98f2-4fb0-aa3b-b4df007ca70a"
  },
  {
    "id": "attack-pattern--acd0ba37-7ba9-4cc5-ac61-796586cd856d",
    "name": "Inter-Process Communication",
    "description": "Adversaries may abuse inter-process communication (IPC) mechanisms for local code or command execution. IPC is typically used by processes to share data, communicate with each other, or synchronize execution. IPC is also commonly used to avoid situations such as deadlocks, which occurs when processes are stuck in a cyclic waiting pattern. \n\nAdversaries may abuse IPC to execute arbitrary code or commands. IPC mechanisms may differ depending on OS, but typically exists in a form accessible through programming languages/libraries or native interfaces such as Windows [Dynamic Data Exchange](https://attack.mitre.org/techniques/T1559/002) or [Component Object Model](https://attack.mitre.org/techniques/T1559/001). Linux environments support several different IPC mechanisms, two of which being sockets and pipes.(Citation: Linux IPC) Higher level execution mediums, such as those of [Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059)s, may also leverage underlying IPC mechanisms. Adversaries may also use [Remote Services](https://attack.mitre.org/techniques/T1021) such as [Distributed Component Object Model](https://attack.mitre.org/techniques/T1021/003) to facilitate remote IPC execution.(Citation: Fireeye Hunting COM June 2019)",
    "tactic": "execution",
    "technique_name": "Inter-Process Communication",
    "technique_id": "T1559",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1559: Inter-Process Communication'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1559: Inter-Process Communication'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1559: Inter-Process Communication'"
      }
    ],
    "ability_id": "attack-pattern--acd0ba37-7ba9-4cc5-ac61-796586cd856d"
  },
  {
    "id": "attack-pattern--b17a1a56-e99c-403c-8948-561df0cffe81",
    "name": "Valid Accounts",
    "description": "Adversaries may obtain and abuse credentials of existing accounts as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Compromised credentials may be used to bypass access controls placed on various resources on systems within the network and may even be used for persistent access to remote systems and externally available services, such as VPNs, Outlook Web Access, network devices, and remote desktop.(Citation: volexity_0day_sophos_FW) Compromised credentials may also grant an adversary increased privilege to specific systems or access to restricted areas of the network. Adversaries may choose not to use malware or tools in conjunction with the legitimate access those credentials provide to make it harder to detect their presence.\n\nIn some cases, adversaries may abuse inactive accounts: for example, those belonging to individuals who are no longer part of an organization. Using these accounts may allow the adversary to evade detection, as the original account user will not be present to identify any anomalous activity taking place on their account.(Citation: CISA MFA PrintNightmare)\n\nThe overlap of permissions for local, domain, and cloud accounts across a network of systems is of concern because the adversary may be able to pivot across accounts and systems to reach a high level of access (i.e., domain or enterprise administrator) to bypass access controls set within the enterprise.(Citation: TechNet Credential Theft)",
    "tactic": "defense-evasion",
    "technique_name": "Valid Accounts",
    "technique_id": "T1078",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1078: Valid Accounts'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1078: Valid Accounts'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1078: Valid Accounts'"
      }
    ],
    "ability_id": "attack-pattern--b17a1a56-e99c-403c-8948-561df0cffe81"
  },
  {
    "id": "attack-pattern--bd369cd9-abb8-41ce-b5bb-fff23ee86c00",
    "name": "Compromise Software Supply Chain",
    "description": "Adversaries may manipulate application software prior to receipt by a final consumer for the purpose of data or system compromise. Supply chain compromise of software can take place in a number of ways, including manipulation of the application source code, manipulation of the update/distribution mechanism for that software, or replacing compiled releases with a modified version.\n\nTargeting may be specific to a desired victim set or may be distributed to a broad set of consumers but only move on to additional tactics on specific victims.(Citation: Avast CCleaner3 2018)(Citation: Command Five SK 2011)  ",
    "tactic": "initial-access",
    "technique_name": "Compromise Software Supply Chain",
    "technique_id": "T1195.002",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1195.002: Compromise Software Supply Chain'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1195.002: Compromise Software Supply Chain'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1195.002: Compromise Software Supply Chain'"
      }
    ],
    "ability_id": "attack-pattern--bd369cd9-abb8-41ce-b5bb-fff23ee86c00"
  },
  {
    "id": "attack-pattern--d742a578-d70e-4d0e-96a6-02a9c30204e6",
    "name": "Drive-by Compromise",
    "description": "Adversaries may gain access to a system through a user visiting a website over the normal course of browsing. Multiple ways of delivering exploit code to a browser exist (i.e., [Drive-by Target](https://attack.mitre.org/techniques/T1608/004)), including:\n\n* A legitimate website is compromised, allowing adversaries to inject malicious code\n* Script files served to a legitimate website from a publicly writeable cloud storage bucket are modified by an adversary\n* Malicious ads are paid for and served through legitimate ad providers (i.e., [Malvertising](https://attack.mitre.org/techniques/T1583/008))\n* Built-in web application interfaces that allow user-controllable content are leveraged for the insertion of malicious scripts or iFrames (e.g., cross-site scripting)\n\nBrowser push notifications may also be abused by adversaries and leveraged for malicious code injection via [User Execution](https://attack.mitre.org/techniques/T1204). By clicking \"allow\" on browser push notifications, users may be granting a website permission to run JavaScript code on their browser.(Citation: Push notifications - viruspositive)(Citation: push notification -mcafee)(Citation: push notifications - malwarebytes)\n\nOften the website used by an adversary is one visited by a specific community, such as government, a particular industry, or a particular region, where the goal is to compromise a specific user or set of users based on a shared interest. This kind of targeted campaign is often referred to a strategic web compromise or watering hole attack. There are several known examples of this occurring.(Citation: Shadowserver Strategic Web Compromise)\n\nTypical drive-by compromise process:\n\n1. A user visits a website that is used to host the adversary controlled content.\n2. Scripts automatically execute, typically searching versions of the browser and plugins for a potentially vulnerable version. The user may be required to assist in this process by enabling scripting, notifications, or active website components and ignoring warning dialog boxes.\n3. Upon finding a vulnerable version, exploit code is delivered to the browser.\n4. If exploitation is successful, the adversary will gain code execution on the user's system unless other protections are in place. In some cases, a second visit to the website after the initial scan is required before exploit code is delivered.\n\nUnlike [Exploit Public-Facing Application](https://attack.mitre.org/techniques/T1190), the focus of this technique is to exploit software on a client endpoint upon visiting a website. This will commonly give an adversary access to systems on the internal network instead of external systems that may be in a DMZ.",
    "tactic": "initial-access",
    "technique_name": "Drive-by Compromise",
    "technique_id": "T1189",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1189: Drive-by Compromise'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1189: Drive-by Compromise'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1189: Drive-by Compromise'"
      }
    ],
    "ability_id": "attack-pattern--d742a578-d70e-4d0e-96a6-02a9c30204e6"
  },
  {
    "id": "attack-pattern--573ad264-1371-4ae0-8482-d2673b719dba",
    "name": "Launch Daemon",
    "description": "Adversaries may create or modify Launch Daemons to execute malicious payloads as part of persistence. Launch Daemons are plist files used to interact with Launchd, the service management framework used by macOS. Launch Daemons require elevated privileges to install, are executed for every user on a system prior to login, and run in the background without the need for user interaction. During the macOS initialization startup, the launchd process loads the parameters for launch-on-demand system-level daemons from plist files found in <code>/System/Library/LaunchDaemons/</code> and <code>/Library/LaunchDaemons/</code>. Required Launch Daemons parameters include a <code>Label</code> to identify the task, <code>Program</code> to provide a path to the executable, and <code>RunAtLoad</code> to specify when the task is run. Launch Daemons are often used to provide access to shared resources, updates to software, or conduct automation tasks.(Citation: AppleDocs Launch Agent Daemons)(Citation: Methods of Mac Malware Persistence)(Citation: launchd Keywords for plists)\n\nAdversaries may install a Launch Daemon configured to execute at startup by using the <code>RunAtLoad</code> parameter set to <code>true</code> and the <code>Program</code> parameter set to the malicious executable path. The daemon name may be disguised by using a name from a related operating system or benign software (i.e. [Masquerading](https://attack.mitre.org/techniques/T1036)). When the Launch Daemon is executed, the program inherits administrative permissions.(Citation: WireLurker)(Citation: OSX Malware Detection)\n\nAdditionally, system configuration changes (such as the installation of third party package managing software) may cause folders such as <code>usr/local/bin</code> to become globally writeable. So, it is possible for poor configurations to allow an adversary to modify executables referenced by current Launch Daemon's plist files.(Citation: LaunchDaemon Hijacking)(Citation: sentinelone macos persist Jun 2019)",
    "tactic": "persistence",
    "technique_name": "Launch Daemon",
    "technique_id": "T1543.004",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1543.004: Launch Daemon'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1543.004: Launch Daemon'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1543.004: Launch Daemon'"
      }
    ],
    "ability_id": "attack-pattern--573ad264-1371-4ae0-8482-d2673b719dba"
  },
  {
    "id": "attack-pattern--a1df809c-7d0e-459f-8fe5-25474bab770b",
    "name": "Delay Execution",
    "description": "Adversaries may employ various time-based methods to evade detection and analysis. These techniques often exploit system clocks, delays, or timing mechanisms to obscure malicious activity, blend in with benign activity, and avoid scrutiny. Adversaries can perform this behavior within virtualization/sandbox environments or natively on host systems. \n\nAdversaries may utilize programmatic `sleep` commands or native system scheduling functionality, for example [Scheduled Task/Job](https://attack.mitre.org/techniques/T1053). Benign commands or other operations may also be used to delay malware execution or ensure prior commands have had time to execute properly. Loops or otherwise needless repetitions of commands, such as `ping`, may be used to delay malware execution and potentially exceed time thresholds of automated analysis environments.(Citation: Revil Independence Day)(Citation: Netskope Nitol) Another variation, commonly referred to as API hammering, involves making various calls to Native API functions in order to delay execution (while also potentially overloading analysis environments with junk data).(Citation: Joe Sec Nymaim)(Citation: Joe Sec Trickbot)",
    "tactic": "defense-evasion",
    "technique_name": "Delay Execution",
    "technique_id": "T1678",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1678: Delay Execution'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1678: Delay Execution'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1678: Delay Execution'"
      }
    ],
    "ability_id": "attack-pattern--a1df809c-7d0e-459f-8fe5-25474bab770b"
  },
  {
    "id": "attack-pattern--365be77f-fc0e-42ee-bac8-4faf806d9336",
    "name": "Msiexec",
    "description": "Adversaries may abuse msiexec.exe to proxy execution of malicious payloads. Msiexec.exe is the command-line utility for the Windows Installer and is thus commonly associated with executing installation packages (.msi).(Citation: Microsoft msiexec) The Msiexec.exe binary may also be digitally signed by Microsoft.\n\nAdversaries may abuse msiexec.exe to launch local or network accessible MSI files. Msiexec.exe can also execute DLLs.(Citation: LOLBAS Msiexec)(Citation: TrendMicro Msiexec Feb 2018) Since it may be signed and native on Windows systems, msiexec.exe can be used to bypass application control solutions that do not account for its potential abuse. Msiexec.exe execution may also be elevated to SYSTEM privileges if the <code>AlwaysInstallElevated</code> policy is enabled.(Citation: Microsoft AlwaysInstallElevated 2018)",
    "tactic": "defense-evasion",
    "technique_name": "Msiexec",
    "technique_id": "T1218.007",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1218.007: Msiexec'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1218.007: Msiexec'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1218.007: Msiexec'"
      }
    ],
    "ability_id": "attack-pattern--365be77f-fc0e-42ee-bac8-4faf806d9336"
  },
  {
    "id": "attack-pattern--f7827069-0bf2-4764-af4f-23fae0d181b7",
    "name": "Dead Drop Resolver",
    "description": "Adversaries may use an existing, legitimate external Web service to host information that points to additional command and control (C2) infrastructure. Adversaries may post content, known as a dead drop resolver, on Web services with embedded (and often obfuscated/encoded) domains or IP addresses. Once infected, victims will reach out to and be redirected by these resolvers.\n\nPopular websites and social media acting as a mechanism for C2 may give a significant amount of cover due to the likelihood that hosts within a network are already communicating with them prior to a compromise. Using common services, such as those offered by Google or Twitter, makes it easier for adversaries to hide in expected noise. Web service providers commonly use SSL/TLS encryption, giving adversaries an added level of protection.\n\nUse of a dead drop resolver may also protect back-end C2 infrastructure from discovery through malware binary analysis while also enabling operational resiliency (since this infrastructure may be dynamically changed).",
    "tactic": "command-and-control",
    "technique_name": "Dead Drop Resolver",
    "technique_id": "T1102.001",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1102.001: Dead Drop Resolver'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1102.001: Dead Drop Resolver'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1102.001: Dead Drop Resolver'"
      }
    ],
    "ability_id": "attack-pattern--f7827069-0bf2-4764-af4f-23fae0d181b7"
  },
  {
    "id": "attack-pattern--2fee9321-3e71-4cf4-af24-d4d40d355b34",
    "name": "DLL",
    "description": "Adversaries may abuse dynamic-link library files (DLLs) in order to achieve persistence, escalate privileges, and evade defenses. DLLs are libraries that contain code and data that can be simultaneously utilized by multiple programs. While DLLs are not malicious by nature, they can be abused through mechanisms such as side-loading, hijacking search order, and phantom DLL hijacking.(Citation: unit 42)\n\nSpecific ways DLLs are abused by adversaries include:\n\n### DLL Sideloading\nAdversaries may execute their own malicious payloads by side-loading DLLs. Side-loading involves hijacking which DLL a program loads by planting and then invoking a legitimate application that executes their payload(s).\n\nSide-loading positions both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.\n\nAdversaries may also side-load other packages, such as BPLs (Borland Package Library).(Citation: kroll bpl)\n\nAdversaries may chain DLL sideloading multiple times to fragment functionality hindering analysis. Adversaries using multiple DLL files can split the loader functions across different DLLs, with a main DLL loading the separated export functions. (Citation: Virus Bulletin) Spreading loader functions across multiple DLLs makes analysis harder, since all files must be collected to fully understand the malware\u2019s behavior.  Another method implements a \u201cloader-for-a-loader\u201d, where a malicious DLL\u2019s sole role is to load a second DLL (or a chain of DLLs) that contain the real payload. (Citation: Sophos)\n\n### DLL Search Order Hijacking\nAdversaries may execute their own malicious payloads by hijacking the search order that Windows uses to load DLLs. This search order is a sequence of special and standard search locations that a program checks when loading a DLL. An adversary can plant a trojan DLL in a directory that will be prioritized by the DLL search order over the location of a legitimate library. This will cause Windows to load the malicious DLL when it is called for by the victim program.(Citation: unit 42)\n\n### DLL Redirection\nAdversaries may directly modify the search order via DLL redirection, which after being enabled (in the Registry or via the creation of a redirection file) may cause a program to load a DLL from a different location.(Citation: Microsoft redirection)(Citation: Microsoft - manifests/assembly)\n\n### Phantom DLL Hijacking\nAdversaries may leverage phantom DLL hijacking by targeting references to non-existent DLL files. They may be able to load their own malicious DLL by planting it with the correct name in the location of the missing module.(Citation: Hexacorn DLL Hijacking)(Citation: Hijack DLLs CrowdStrike)\n\n### DLL Substitution\nAdversaries may target existing, valid DLL files and substitute them with their own malicious DLLs, planting them with the same name and in the same location as the valid DLL file.(Citation: Wietze Beukema DLL Hijacking)\n\nPrograms that fall victim to DLL hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace, evading defenses.\n\nRemote DLL hijacking can occur when a program sets its current directory to a remote location, such as a Web share, before loading a DLL.(Citation: dll pre load owasp)(Citation: microsoft remote preloading)\n\nIf a valid DLL is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation.",
    "tactic": "persistence",
    "technique_name": "DLL",
    "technique_id": "T1574.001",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1574.001: DLL'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1574.001: DLL'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1574.001: DLL'"
      }
    ],
    "ability_id": "attack-pattern--2fee9321-3e71-4cf4-af24-d4d40d355b34"
  },
  {
    "id": "attack-pattern--4933e63b-9b77-476e-ab29-761bc5b7d15a",
    "name": "Reflective Code Loading",
    "description": "Adversaries may reflectively load code into a process in order to conceal the execution of malicious payloads. Reflective loading involves allocating then executing payloads directly within the memory of the process, vice creating a thread or process backed by a file path on disk (e.g., [Shared Modules](https://attack.mitre.org/techniques/T1129)).\n\nReflectively loaded payloads may be compiled binaries, anonymous files (only present in RAM), or just snubs of fileless executable code (ex: position-independent shellcode).(Citation: Introducing Donut)(Citation: S1 Custom Shellcode Tool)(Citation: Stuart ELF Memory)(Citation: 00sec Droppers)(Citation: Mandiant BYOL) For example, the `Assembly.Load()` method executed by [PowerShell](https://attack.mitre.org/techniques/T1059/001) may be abused to load raw code into the running process.(Citation: Microsoft AssemblyLoad)\n\nReflective code injection is very similar to [Process Injection](https://attack.mitre.org/techniques/T1055) except that the \u201cinjection\u201d loads code into the processes\u2019 own memory instead of that of a separate process. Reflective loading may evade process-based detections since the execution of the arbitrary code may be masked within a legitimate or otherwise benign process. Reflectively loading payloads directly into memory may also avoid creating files or other artifacts on disk, while also enabling malware to keep these payloads encrypted (or otherwise obfuscated) until execution.(Citation: Stuart ELF Memory)(Citation: 00sec Droppers)(Citation: Intezer ACBackdoor)(Citation: S1 Old Rat New Tricks)",
    "tactic": "defense-evasion",
    "technique_name": "Reflective Code Loading",
    "technique_id": "T1620",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1620: Reflective Code Loading'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1620: Reflective Code Loading'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1620: Reflective Code Loading'"
      }
    ],
    "ability_id": "attack-pattern--4933e63b-9b77-476e-ab29-761bc5b7d15a"
  },
  {
    "id": "attack-pattern--32901740-b42c-4fdd-bc02-345b5dc57082",
    "name": "Code Signing",
    "description": "Adversaries may create, acquire, or steal code signing materials to sign their malware or tools. Code signing provides a level of authenticity on a binary from the developer and a guarantee that the binary has not been tampered with. (Citation: Wikipedia Code Signing) The certificates used during an operation may be created, acquired, or stolen by the adversary. (Citation: Securelist Digital Certificates) (Citation: Symantec Digital Certificates) Unlike [Invalid Code Signature](https://attack.mitre.org/techniques/T1036/001), this activity will result in a valid signature.\n\nCode signing to verify software on first run can be used on modern Windows and macOS systems. It is not used on Linux due to the decentralized nature of the platform. (Citation: Wikipedia Code Signing)(Citation: EclecticLightChecksonEXECodeSigning)\n\nCode signing certificates may be used to bypass security policies that require signed code to execute on a system. ",
    "tactic": "defense-evasion",
    "technique_name": "Code Signing",
    "technique_id": "T1553.002",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1553.002: Code Signing'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1553.002: Code Signing'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1553.002: Code Signing'"
      }
    ],
    "ability_id": "attack-pattern--32901740-b42c-4fdd-bc02-345b5dc57082"
  },
  {
    "id": "attack-pattern--5e4a2073-9643-44cb-a0b5-e7f4048446c7",
    "name": "Browser Information Discovery",
    "description": "Adversaries may enumerate information about browsers to learn more about compromised environments. Data saved by browsers (such as bookmarks, accounts, and browsing history) may reveal a variety of personal information about users (e.g., banking sites, relationships/interests, social media, etc.) as well as details about internal network resources such as servers, tools/dashboards, or other related infrastructure.(Citation: Kaspersky Autofill)\n\nBrowser information may also highlight additional targets after an adversary has access to valid credentials, especially [Credentials In Files](https://attack.mitre.org/techniques/T1552/001) associated with logins cached by a browser.\n\nSpecific storage locations vary based on platform and/or application, but browser information is typically stored in local files and databases (e.g., `%APPDATA%/Google/Chrome`).(Citation: Chrome Roaming Profiles)",
    "tactic": "discovery",
    "technique_name": "Browser Information Discovery",
    "technique_id": "T1217",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1217: Browser Information Discovery'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1217: Browser Information Discovery'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1217: Browser Information Discovery'"
      }
    ],
    "ability_id": "attack-pattern--5e4a2073-9643-44cb-a0b5-e7f4048446c7"
  },
  {
    "id": "attack-pattern--43e7dc91-05b2-474c-b9ac-2ed4fe101f4d",
    "name": "Process Injection",
    "description": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. \n\nThere are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. \n\nMore sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel. ",
    "tactic": "defense-evasion",
    "technique_name": "Process Injection",
    "technique_id": "T1055",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1055: Process Injection'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1055: Process Injection'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1055: Process Injection'"
      }
    ],
    "ability_id": "attack-pattern--43e7dc91-05b2-474c-b9ac-2ed4fe101f4d"
  },
  {
    "id": "attack-pattern--0d91b3c0-5e50-47c3-949a-2a796f04d144",
    "name": "Encrypted/Encoded File",
    "description": "Adversaries may encrypt or encode files to obfuscate strings, bytes, and other specific patterns to impede detection. Encrypting and/or encoding file content aims to conceal malicious artifacts within a file used in an intrusion. Many other techniques, such as [Software Packing](https://attack.mitre.org/techniques/T1027/002), [Steganography](https://attack.mitre.org/techniques/T1027/003), and [Embedded Payloads](https://attack.mitre.org/techniques/T1027/009), share this same broad objective. Encrypting and/or encoding files could lead to a lapse in detection of static signatures, only for this malicious content to be revealed (i.e., [Deobfuscate/Decode Files or Information](https://attack.mitre.org/techniques/T1140)) at the time of execution/use.\n\nThis type of file obfuscation can be applied to many file artifacts present on victim hosts, such as malware log/configuration and payload files.(Citation: File obfuscation) Files can be encrypted with a hardcoded or user-supplied key, as well as otherwise obfuscated using standard encoding schemes such as Base64.\n\nThe entire content of a file may be obfuscated, or just specific functions or values (such as C2 addresses). Encryption and encoding may also be applied in redundant layers for additional protection.\n\nFor example, adversaries may abuse password-protected Word documents or self-extracting (SFX) archives as a method of encrypting/encoding a file such as a [Phishing](https://attack.mitre.org/techniques/T1566) payload. These files typically function by attaching the intended archived content to a decompressor stub that is executed when the file is invoked (e.g., [User Execution](https://attack.mitre.org/techniques/T1204)).(Citation: SFX - Encrypted/Encoded File) \n\nAdversaries may also abuse file-specific as well as custom encoding schemes. For example, Byte Order Mark (BOM) headers in text files may be abused to manipulate and obfuscate file content until [Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059) execution.",
    "tactic": "defense-evasion",
    "technique_name": "Encrypted/Encoded File",
    "technique_id": "T1027.013",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1027.013: Encrypted/Encoded File'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1027.013: Encrypted/Encoded File'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1027.013: Encrypted/Encoded File'"
      }
    ],
    "ability_id": "attack-pattern--0d91b3c0-5e50-47c3-949a-2a796f04d144"
  },
  {
    "id": "attack-pattern--df8b2a25-8bdf-4856-953c-a04372b1c161",
    "name": "Web Protocols",
    "description": "Adversaries may communicate using application layer protocols associated with web traffic to avoid detection/network filtering by blending in with existing traffic. Commands to the remote system, and often the results of those commands, will be embedded within the protocol traffic between the client and server. \n\nProtocols such as HTTP/S(Citation: CrowdStrike Putter Panda) and WebSocket(Citation: Brazking-Websockets) that carry web traffic may be very common in environments. HTTP/S packets have many fields and headers in which data can be concealed. An adversary may abuse these protocols to communicate with systems under their control within a victim network while also mimicking normal, expected traffic. ",
    "tactic": "command-and-control",
    "technique_name": "Web Protocols",
    "technique_id": "T1071.001",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1071.001: Web Protocols'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1071.001: Web Protocols'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1071.001: Web Protocols'"
      }
    ],
    "ability_id": "attack-pattern--df8b2a25-8bdf-4856-953c-a04372b1c161"
  },
  {
    "id": "attack-pattern--0533ab23-3f7d-463f-9bd8-634d27e4dee1",
    "name": "Embedded Payloads",
    "description": "Adversaries may embed payloads within other files to conceal malicious content from defenses. Otherwise seemingly benign files (such as scripts and executables) may be abused to carry and obfuscate malicious payloads and content. In some cases, embedded payloads may also enable adversaries to [Subvert Trust Controls](https://attack.mitre.org/techniques/T1553) by not impacting execution controls such as digital signatures and notarization tickets.(Citation: Sentinel Labs) \n\nAdversaries may embed payloads in various file formats to hide payloads.(Citation: Microsoft Learn) This is similar to [Steganography](https://attack.mitre.org/techniques/T1027/003), though does not involve weaving malicious content into specific bytes and patterns related to legitimate digital media formats.(Citation: GitHub PSImage) \n\nFor example, adversaries have been observed embedding payloads within or as an overlay of an otherwise benign binary.(Citation: Securelist Dtrack2) Adversaries have also been observed nesting payloads (such as executables and run-only scripts) inside a file of the same format.(Citation: SentinelLabs reversing run-only applescripts 2021) \n\nEmbedded content may also be used as [Process Injection](https://attack.mitre.org/techniques/T1055) payloads used to infect benign system processes.(Citation: Trend Micro) These embedded then injected payloads may be used as part of the modules of malware designed to provide specific features such as encrypting C2 communications in support of an orchestrator module. For example, an embedded module may be injected into default browsers, allowing adversaries to then communicate via the network.(Citation: Malware Analysis Report ComRAT)",
    "tactic": "defense-evasion",
    "technique_name": "Embedded Payloads",
    "technique_id": "T1027.009",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1027.009: Embedded Payloads'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1027.009: Embedded Payloads'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1027.009: Embedded Payloads'"
      }
    ],
    "ability_id": "attack-pattern--0533ab23-3f7d-463f-9bd8-634d27e4dee1"
  },
  {
    "id": "attack-pattern--24bfaeba-cb0d-4525-b3dc-507c77ecec41",
    "name": "Symmetric Cryptography",
    "description": "Adversaries may employ a known symmetric encryption algorithm to conceal command and control traffic rather than relying on any inherent protections provided by a communication protocol. Symmetric encryption algorithms use the same key for plaintext encryption and ciphertext decryption. Common symmetric encryption algorithms include AES, DES, 3DES, Blowfish, and RC4.",
    "tactic": "command-and-control",
    "technique_name": "Symmetric Cryptography",
    "technique_id": "T1573.001",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1573.001: Symmetric Cryptography'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1573.001: Symmetric Cryptography'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1573.001: Symmetric Cryptography'"
      }
    ],
    "ability_id": "attack-pattern--24bfaeba-cb0d-4525-b3dc-507c77ecec41"
  },
  {
    "id": "attack-pattern--da051493-ae9c-4b1b-9760-c009c46c9b56",
    "name": "Installer Packages",
    "description": "Adversaries may establish persistence and elevate privileges by using an installer to trigger the execution of malicious content. Installer packages are OS specific and contain the resources an operating system needs to install applications on a system. Installer packages can include scripts that run prior to installation as well as after installation is complete. Installer scripts may inherit elevated permissions when executed. Developers often use these scripts to prepare the environment for installation, check requirements, download dependencies, and remove files after installation.(Citation: Installer Package Scripting Rich Trouton)\n\nUsing legitimate applications, adversaries have distributed applications with modified installer scripts to execute malicious content. When a user installs the application, they may be required to grant administrative permissions to allow the installation. At the end of the installation process of the legitimate application, content such as macOS `postinstall` scripts can be executed with the inherited elevated permissions. Adversaries can use these scripts to execute a malicious executable or install other malicious components (such as a [Launch Daemon](https://attack.mitre.org/techniques/T1543/004)) with the elevated permissions.(Citation: Application Bundle Manipulation Brandon Dalton)(Citation: wardle evilquest parti)(Citation: Windows AppleJeus GReAT)(Citation: Debian Manual Maintainer Scripts)\n\nDepending on the distribution, Linux versions of package installer scripts are sometimes called maintainer scripts or post installation scripts. These scripts can include `preinst`, `postinst`, `prerm`, `postrm` scripts and run as root when executed.\n\nFor Windows, the Microsoft Installer services uses `.msi` files to manage the installing, updating, and uninstalling of applications. These installation routines may also include instructions to perform additional actions that may be abused by adversaries.(Citation: Microsoft Installation Procedures)",
    "tactic": "privilege-escalation",
    "technique_name": "Installer Packages",
    "technique_id": "T1546.016",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1546.016: Installer Packages'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1546.016: Installer Packages'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1546.016: Installer Packages'"
      }
    ],
    "ability_id": "attack-pattern--da051493-ae9c-4b1b-9760-c009c46c9b56"
  },
  {
    "id": "attack-pattern--806a49c4-970d-43f9-9acc-ac0ee11e6662",
    "name": "Portable Executable Injection",
    "description": "Adversaries may inject portable executables (PE) into processes in order to evade process-based defenses as well as possibly elevate privileges. PE injection is a method of executing arbitrary code in the address space of a separate live process. \n\nPE injection is commonly performed by copying code (perhaps without a file on disk) into the virtual address space of the target process before invoking it via a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> or additional code (ex: shellcode). The displacement of the injected code does introduce the additional requirement for functionality to remap memory references. (Citation: Elastic Process Injection July 2017) \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via PE injection may also evade detection from security products since the execution is masked under a legitimate process. ",
    "tactic": "defense-evasion",
    "technique_name": "Portable Executable Injection",
    "technique_id": "T1055.002",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1055.002: Portable Executable Injection'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1055.002: Portable Executable Injection'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1055.002: Portable Executable Injection'"
      }
    ],
    "ability_id": "attack-pattern--806a49c4-970d-43f9-9acc-ac0ee11e6662"
  },
  {
    "id": "attack-pattern--561ae9aa-c28a-4144-9eec-e7027a14c8c3",
    "name": "Electron Applications",
    "description": "Adversaries may abuse components of the Electron framework to execute malicious code. The Electron framework hosts many common applications such as Signal, Slack, and Microsoft Teams.(Citation: Electron 2) Originally developed by GitHub, Electron is a cross-platform desktop application development framework that employs web technologies like JavaScript, HTML, and CSS.(Citation: Electron 3) The Chromium engine is used to display web content and Node.js runs the backend code.(Citation: Electron 1)\n\nDue to the functional mechanics of Electron (such as allowing apps to run arbitrary commands), adversaries may also be able to perform malicious functions in the background potentially disguised as legitimate tools within the framework.(Citation: Electron 1) For example, the abuse of `teams.exe` and `chrome.exe` may allow adversaries to execute malicious commands as child processes of the legitimate application (e.g., `chrome.exe --disable-gpu-sandbox --gpu-launcher=\"C:\\Windows\\system32\\cmd.exe /c calc.exe`).(Citation: Electron 6-8)\n\nAdversaries may also execute malicious content by planting malicious [JavaScript](https://attack.mitre.org/techniques/T1059/007) within Electron applications.(Citation: Electron Security)",
    "tactic": "defense-evasion",
    "technique_name": "Electron Applications",
    "technique_id": "T1218.015",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1218.015: Electron Applications'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1218.015: Electron Applications'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1218.015: Electron Applications'"
      }
    ],
    "ability_id": "attack-pattern--561ae9aa-c28a-4144-9eec-e7027a14c8c3"
  },
  {
    "id": "attack-pattern--be2dcee9-a7a7-4e38-afd6-21b31ecc3d63",
    "name": "Exploitation for Client Execution",
    "description": "Adversaries may exploit software vulnerabilities in client applications to execute code. Vulnerabilities can exist in software due to unsecure coding practices that can lead to unanticipated behavior. Adversaries can take advantage of certain vulnerabilities through targeted exploitation for the purpose of arbitrary code execution. Oftentimes the most valuable exploits to an offensive toolkit are those that can be used to obtain code execution on a remote system because they can be used to gain access to that system. Users will expect to see files related to the applications they commonly used to do work, so they are a useful target for exploit research and development because of their high utility.\n\nSeveral types exist:\n\n### Browser-based Exploitation\n\nWeb browsers are a common target through [Drive-by Compromise](https://attack.mitre.org/techniques/T1189) and [Spearphishing Link](https://attack.mitre.org/techniques/T1566/002). Endpoint systems may be compromised through normal web browsing or from certain users being targeted by links in spearphishing emails to adversary controlled sites used to exploit the web browser. These often do not require an action by the user for the exploit to be executed.\n\n### Office Applications\n\nCommon office and productivity applications such as Microsoft Office are also targeted through [Phishing](https://attack.mitre.org/techniques/T1566). Malicious files will be transmitted directly as attachments or through links to download them. These require the user to open the document or file for the exploit to run.\n\n### Common Third-party Applications\n\nOther applications that are commonly seen or are part of the software deployed in a target network may also be used for exploitation. Applications such as Adobe Reader and Flash, which are common in enterprise environments, have been routinely targeted by adversaries attempting to gain access to systems. Depending on the software and nature of the vulnerability, some may be exploited in the browser or require the user to open a file. For instance, some Flash exploits have been delivered as objects within Microsoft Office documents.",
    "tactic": "execution",
    "technique_name": "Exploitation for Client Execution",
    "technique_id": "T1203",
    "executors": [
      {
        "name": "sh",
        "platform": "linux",
        "command": "echo 'Simulated execution of T1203: Exploitation for Client Execution'"
      },
      {
        "name": "psh",
        "platform": "windows",
        "command": "Write-Host 'Simulated execution of T1203: Exploitation for Client Execution'"
      },
      {
        "name": "sh",
        "platform": "darwin",
        "command": "echo 'Simulated execution of T1203: Exploitation for Client Execution'"
      }
    ],
    "ability_id": "attack-pattern--be2dcee9-a7a7-4e38-afd6-21b31ecc3d63"
  }
]